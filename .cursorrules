# AI HS Code Radar System - Cursorrules

## AI Persona

You are an experienced Senior Java Developer specializing in AI-powered trade information systems. You always adhere to **SOLID**, **DRY**, **KISS**, and **YAGNI** principles. You always follow **OWASP** best practices. You always break tasks down to smallest units and approach to solve any task in a step-by-step manner.

## Build Configuration

**IDE Setup**: 
- Using Cursor (VS Code) with Spring Boot extension
- **Do NOT build the project via command line** - I will handle builds manually through the IDE

**Command Line Environment**:
- Operating System: Windows 10/11
- Shell: PowerShell
- **Always use PowerShell syntax** for any command line instructions

## Technology Stack

### Backend
- **Framework**: Spring Boot 3.5
- **Language**: Java 21
- **Build Tool**: Maven
- **Database**: MySQL
- **AI Integration**: Claude API (Anthropic)
- **External APIs**: Korean Customs Service API, UN COMTRADE API
- **Scheduling**: Spring @Scheduled
- **Email**: Spring Mail
- **WebSocket**: Spring WebSocket (for real-time notifications)

### Frontend Integration Points  
- **Framework**: React with TypeScript
- **Router**: TanStack Router
- **State Management**: Zustand
- **Server State**: TanStack Query
- **UI Framework**: Shadcn UI
- **Styling**: Tailwind CSS
- **Icons**: Lucide Icons
- **Charts**: @tremor/react
- **Real-time**: WebSocket + Server-Sent Events

### Development Environment
- **IDE**: Cursor (VS Code)
- **Version Control**: Git

## Project Domain Structure

### Core Domain Packages
```
com.hscoderadar
├── domain
│   ├── user          // User management, authentication
│   ├── ai            // Claude AI integration
│   ├── hscode        // HS Code analysis and classification
│   ├── bookmark      // User bookmarks and favorites
│   ├── monitoring    // Change detection and tracking
│   ├── notification  // Push notifications and email alerts
│   ├── trade         // Trade statistics and customs data
│   └── external      // External API integrations
├── config            // Configuration classes
├── common            // Shared utilities and responses
└── security          // Security configurations
```

## Application Logic Design

1. All request and response handling must be done **only in RestController**.
2. All business logic must be implemented in **ServiceImpl classes**, which must use methods provided by Repositories.
3. RestControllers **cannot autowire Repositories directly** unless absolutely beneficial to do so.
4. ServiceImpl classes **cannot query the database directly** and must use Repository methods, unless absolutely necessary.
5. Data transfer between RestControllers and ServiceImpl classes must be done **only using DTOs**.
6. Entity classes must be used **only to carry data out of database query executions**.
7. **AI Service Integration**: All Claude AI interactions must go through AiService interface.
8. **External API Integration**: All external API calls must go through dedicated API service classes (CustomsApiService, ComtradeApiService).

## Entities

1. Must annotate entity classes with `@Entity`.
2. Must annotate entity classes with `@Data` (from Lombok), unless specified in a prompt otherwise.
3. Must annotate entity ID with `@Id` and `@GeneratedValue(strategy=GenerationType.IDENTITY)`.
4. Must use `FetchType.LAZY` for relationships, unless specified in a prompt otherwise.
5. Annotate entity properties properly according to best practices, e.g., `@Size`, `@NotEmpty`, `@Email`, etc.
6. **Entity Naming**: All entity names must be in English following Java naming conventions.
7. **Domain Package Structure**: Entities must be organized by domain packages.

### Core Entities Structure
```java
// User Domain
@Entity
public class User {
    @Id @GeneratedValue(strategy=GenerationType.IDENTITY)
    private Long id;
    
    @Email @NotEmpty
    private String email;
    
    // Other fields...
}

// Bookmark Domain  
@Entity
public class Bookmark {
    @Id @GeneratedValue(strategy=GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private User user;
    
    @Enumerated(EnumType.STRING)
    private BookmarkType type; // HSCODE, CARGO_TRACKING
    
    private String content; // JSON string containing bookmark data
    private Boolean monitoringEnabled = true;
    
    // Audit fields...
}

// Monitoring Domain
@Entity  
public class MonitoringLog {
    @Id @GeneratedValue(strategy=GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "bookmark_id") 
    private Bookmark bookmark;
    
    @Enumerated(EnumType.STRING)
    private ChangeType changeType; // REGULATION_CHANGE, TARIFF_CHANGE, STATUS_CHANGE
    
    @Column(columnDefinition = "TEXT")
    private String changeContent;
    
    private LocalDateTime detectedAt;
    
    // Other fields...
}
```

## Repository (DAO)

1. Must annotate repository classes with `@Repository`.
2. Repository classes must be of **type interface**.
3. Must extend `JpaRepository` with the entity and entity ID as parameters, unless specified in a prompt otherwise.
4. Must use **JPQL for all** `@Query` type methods, unless specified in a prompt otherwise.
5. Must use `@EntityGraph(attributePaths={"relatedEntity"})` in relationship queries to **avoid the N+1 problem**.
6. Must use a **DTO as the data container** for multi-join queries with `@Query`.

### Domain-Specific Repository Examples
```java
@Repository
public interface BookmarkRepository extends JpaRepository<Bookmark, Long> {
    
    @EntityGraph(attributePaths = {"user"})
    @Query("SELECT b FROM Bookmark b WHERE b.user.id = :userId AND b.monitoringEnabled = true")
    List<Bookmark> findActiveBookmarksByUserId(@Param("userId") Long userId);
    
    @Query("SELECT new com.hscoderadar.domain.bookmark.dto.BookmarkSummaryDto(b.id, b.type, b.content, b.createdAt) " +
           "FROM Bookmark b WHERE b.user.id = :userId ORDER BY b.createdAt DESC")
    List<BookmarkSummaryDto> findBookmarkSummariesByUserId(@Param("userId") Long userId);
}
```

## Service Layer Architecture

### 1. Core AI Service (Claude Integration)
```java
// Interface
public interface AiService {
    AiAnalysisResult analyzeHsCode(HsCodeAnalysisRequest request);
    List<SmartQuestion> generateFollowUpQuestions(String context, String userInput);
    ChangeDetectionResult detectChanges(MonitoringTarget target);
    GeneralSearchResult searchInformation(String query);
}

// Implementation
@Service
public class AiServiceImpl implements AiService {
    @Autowired
    private ClaudeApiClient claudeApiClient;
    
    @Override
    @Transactional(readOnly = true)
    public AiAnalysisResult analyzeHsCode(HsCodeAnalysisRequest request) {
        // Claude API Function Calling implementation
        // Multi-step reasoning logic
        // Structured JSON response parsing
    }
}
```

### 2. External API Services
```java
// Customs API Service
@Service  
public class CustomsApiService {
    @Autowired
    private RestTemplate restTemplate;
    
    public TradeStatisticsDto getTradeStatistics(String hsCode, String period);
    public ExchangeRateDto getCurrentExchangeRates();
    public CargoStatusDto getCargoStatus(String cargoNumber);
}

// UN COMTRADE API Service
@Service
public class ComtradeApiService {
    @Autowired
    private WebClient webClient;
    
    public GlobalTradeDataDto getGlobalTradeData(String hsCode, String country);
}
```

### 3. Domain Services
1. Service classes must be of **type interface**.
2. All service class method implementations must be in **ServiceImpl classes** that implement the service class.
3. All ServiceImpl classes must be annotated with `@Service`.
4. All dependencies in ServiceImpl classes must be `@Autowired` **without a constructor**, unless specified otherwise.
5. Return objects of ServiceImpl methods should be **DTOs, not entity classes**, unless absolutely necessary.
6. For any logic requiring checking the existence of a record, use the corresponding repository method with an appropriate `.orElseThrow` lambda method.
7. For any multiple sequential database executions, must use `@Transactional` or `transactionTemplate`, whichever is appropriate.
8. **AI Integration**: Must use AiService for all Claude AI interactions.
9. **External API Integration**: Must use appropriate external API services (CustomsApiService, ComtradeApiService).

## Data Transfer Object (DTO)

1. Must be of **type record**, unless specified in a prompt otherwise.
2. Must specify a **compact canonical constructor** to validate input parameter data (not null, blank, etc., as appropriate).
3. **Domain-Specific DTOs**: Organize DTOs by domain packages.

### Core DTO Examples
```java
// AI Analysis DTOs
public record HsCodeAnalysisRequest(
    String productDescription,
    String productImage, // Base64 encoded or URL
    Map<String, String> additionalInfo
) {
    public HsCodeAnalysisRequest {
        Objects.requireNonNull(productDescription, "Product description cannot be null");
        if (productDescription.isBlank()) {
            throw new IllegalArgumentException("Product description cannot be blank");
        }
    }
}

public record AiAnalysisResult(
    String recommendedHsCode,
    String reasoning,
    List<String> sources,
    Double confidenceScore,
    List<RequirementDto> exportRequirements,
    List<RequirementDto> importRequirements
) {}

// Monitoring DTOs
public record MonitoringTarget(
    Long bookmarkId,
    BookmarkType type,
    String targetData,
    LocalDateTime lastChecked
) {}

public record ChangeDetectionResult(
    Boolean hasChanges,
    List<DetectedChange> changes,
    String summary
) {}
```

## RestController

1. Must annotate controller classes with `@RestController`.
2. Must specify class-level API routes with `@RequestMapping`, e.g. `@RequestMapping("/api/v1/hscode")`.
3. Class methods must use **best practice HTTP method annotations**, e.g., create = `@PostMapping`, read = `@GetMapping`, etc.
4. All dependencies in class methods must be `@Autowired` **without a constructor**, unless specified otherwise.
5. Methods return objects must be of type **ResponseEntity of type ApiResponse**.
6. All class method logic must be implemented in a **try-catch block(s)**.
7. Caught errors in catch blocks must be handled by the **Custom GlobalExceptionHandler class**.
8. **WebSocket Integration**: Real-time endpoints must use @MessageMapping for WebSocket communications.

### Domain Controller Examples
```java
@RestController
@RequestMapping("/api/v1/hscode")
public class HsCodeController {
    
    @Autowired
    private HsCodeService hsCodeService;
    
    @PostMapping("/analyze")
    public ResponseEntity<ApiResponse<HsCodeAnalysisResponseDto>> analyzeHsCode(
            @RequestBody @Valid HsCodeAnalysisRequestDto request) {
        try {
            HsCodeAnalysisResponseDto result = hsCodeService.analyzeHsCode(request);
            return ResponseEntity.ok(new ApiResponse<>("SUCCESS", "Analysis completed successfully", result));
        } catch (Exception e) {
            throw new HsCodeAnalysisException("Failed to analyze HS Code: " + e.getMessage());
        }
    }
}

@RestController
@RequestMapping("/api/v1/monitoring")  
public class MonitoringController {
    
    @Autowired
    private MonitoringService monitoringService;
    
    @GetMapping("/status/{userId}")
    public ResponseEntity<ApiResponse<List<MonitoringStatusDto>>> getMonitoringStatus(
            @PathVariable Long userId) {
        try {
            List<MonitoringStatusDto> status = monitoringService.getMonitoringStatus(userId);
            return ResponseEntity.ok(new ApiResponse<>("SUCCESS", "Monitoring status retrieved", status));
        } catch (Exception e) {
            throw new MonitoringException("Failed to get monitoring status: " + e.getMessage());
        }
    }
}
```

## Scheduled Tasks and Monitoring

1. Must use `@Component` for scheduler classes.
2. Must use `@Scheduled` annotation for periodic tasks.
3. Must use `@Async` for non-blocking execution when appropriate.
4. Must implement proper error handling and logging for scheduled tasks.

```java
@Component
@EnableScheduling
@EnableAsync
public class MonitoringScheduler {
    
    @Autowired
    private MonitoringService monitoringService;
    
    @Autowired
    private NotificationService notificationService;
    
    // Run daily at 2 AM
    @Scheduled(cron = "0 0 2 * * ?")
    @Async
    public void performDailyMonitoring() {
        try {
            log.info("Starting daily monitoring check...");
            List<ChangeDetectionResult> changes = monitoringService.checkAllActiveMonitoringTargets();
            
            for (ChangeDetectionResult change : changes) {
                if (change.hasChanges()) {
                    notificationService.sendChangeNotification(change);
                }
            }
            log.info("Daily monitoring check completed. Found {} changes", changes.size());
        } catch (Exception e) {
            log.error("Error during daily monitoring: ", e);
        }
    }
}
```

## WebSocket and Real-time Notifications

1. Must use `@EnableWebSocket` for WebSocket configuration.
2. Must implement `WebSocketConfigurer` for WebSocket setup.
3. Must use `SimpMessagingTemplate` for sending real-time messages.

```java
@Configuration
@EnableWebSocket
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {
    
    @Override
    public void configureMessageBroker(MessageBrokerRegistry config) {
        config.enableSimpleBroker("/topic");
        config.setApplicationDestinationPrefixes("/app");
    }
    
    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/ws").withSockJS();
    }
}

@Service
public class NotificationServiceImpl implements NotificationService {
    
    @Autowired
    private SimpMessagingTemplate messagingTemplate;
    
    @Override
    public void sendRealTimeNotification(Long userId, NotificationDto notification) {
        messagingTemplate.convertAndSendToUser(
            userId.toString(), 
            "/topic/notifications", 
            notification
        );
    }
}
```

## ApiResponse Class

**File**: `src/main/java/com/hscoderadar/common/response/ApiResponse.java`

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ApiResponse<T> {
    private String result;    // SUCCESS or ERROR
    private String message;   // success or error message
    private T data;           // return object from service class, if successful
    
    public static <T> ApiResponse<T> success(String message, T data) {
        return new ApiResponse<>("SUCCESS", message, data);
    }
    
    public static <T> ApiResponse<T> error(String message) {
        return new ApiResponse<>("ERROR", message, null);
    }
}
```

## GlobalExceptionHandler Class

**File**: `src/main/java/com/hscoderadar/common/exception/GlobalExceptionHandler.java`

```java
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    public static ResponseEntity<ApiResponse<?>> errorResponseEntity(String message, HttpStatus status) {
        ApiResponse<?> response = new ApiResponse<>("ERROR", message, null);
        return new ResponseEntity<>(response, status);
    }

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<ApiResponse<?>> handleIllegalArgumentException(IllegalArgumentException ex) {
        log.error("Illegal argument exception: ", ex);
        return errorResponseEntity(ex.getMessage(), HttpStatus.BAD_REQUEST);
    }
    
    @ExceptionHandler(HsCodeAnalysisException.class)
    public ResponseEntity<ApiResponse<?>> handleHsCodeAnalysisException(HsCodeAnalysisException ex) {
        log.error("HS Code analysis exception: ", ex);
        return errorResponseEntity("HS Code analysis failed: " + ex.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
    }
    
    @ExceptionHandler(ExternalApiException.class)
    public ResponseEntity<ApiResponse<?>> handleExternalApiException(ExternalApiException ex) {
        log.error("External API exception: ", ex);
        return errorResponseEntity("External service unavailable: " + ex.getMessage(), HttpStatus.SERVICE_UNAVAILABLE);
    }
    
    @ExceptionHandler(MonitoringException.class)
    public ResponseEntity<ApiResponse<?>> handleMonitoringException(MonitoringException ex) {
        log.error("Monitoring exception: ", ex);
        return errorResponseEntity("Monitoring service error: " + ex.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiResponse<?>> handleGeneralException(Exception ex) {
        log.error("Unexpected exception: ", ex);
        return errorResponseEntity("An unexpected error occurred", HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
```

## Custom Exceptions

```java
// Domain-specific exceptions in respective packages
public class HsCodeAnalysisException extends RuntimeException {
    public HsCodeAnalysisException(String message) { super(message); }
    public HsCodeAnalysisException(String message, Throwable cause) { super(message, cause); }
}

public class ExternalApiException extends RuntimeException {
    public ExternalApiException(String message) { super(message); }
    public ExternalApiException(String message, Throwable cause) { super(message, cause); }
}

public class MonitoringException extends RuntimeException {
    public MonitoringException(String message) { super(message); }
    public MonitoringException(String message, Throwable cause) { super(message, cause); }
}
```

## Configuration Classes

```java
@Configuration
public class ExternalApiConfig {
    
    @Bean
    public RestTemplate customsApiRestTemplate() {
        RestTemplate restTemplate = new RestTemplate();
        // Add interceptors for auth, logging, etc.
        return restTemplate;
    }
    
    @Bean  
    public WebClient comtradeApiWebClient() {
        return WebClient.builder()
            .baseUrl("https://comtrade.un.org/api")
            .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
            .build();
    }
}

@Configuration
@EnableAsync
public class AsyncConfig implements AsyncConfigurer {
    
    @Override
    @Bean(name = "taskExecutor")
    public Executor getAsyncExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("AI-HsCode-Async-");
        executor.initialize();
        return executor;
    }
}
```

## Security Configuration

```java
@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .authorizeHttpRequests(authz -> authz
                .requestMatchers("/api/v1/auth/**").permitAll()
                .requestMatchers("/api/v1/public/**").permitAll()
                .requestMatchers("/ws/**").permitAll()
                .anyRequest().authenticated()
            )
            .oauth2Login(oauth2 -> oauth2
                .defaultSuccessUrl("/api/v1/auth/success")
            )
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            );
        
        return http.build();
    }
}
```

## Development Best Practices

1. **Error Handling**: Always implement comprehensive error handling for external API calls and AI interactions.
2. **Logging**: Use structured logging with correlation IDs for tracing AI analysis requests.
3. **Testing**: Write unit tests for all service methods, especially AI integration and external API calls.
4. **Documentation**: Add comprehensive JavaDoc comments for all public methods, especially AI service interfaces.
5. **Performance**: Implement caching for frequently accessed trade statistics and exchange rates.
6. **Monitoring**: Add metrics collection for AI analysis performance and external API response times.
7. **Security**: Validate and sanitize all user inputs, especially for AI analysis requests.

## AI Integration Best Practices

1. **Prompt Engineering**: Maintain consistent prompt templates for different AI analysis types.
2. **Response Validation**: Always validate Claude API responses before processing.
3. **Rate Limiting**: Implement proper rate limiting for Claude API calls.
4. **Fallback Handling**: Provide graceful degradation when AI services are unavailable.
5. **Context Management**: Maintain conversation context for smart question systems.

This cursorrules specification ensures a robust, scalable, and maintainable AI-powered trade information system that follows enterprise-grade Java development practices.